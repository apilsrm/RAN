**Arduino IR Encoder Speed Motion Sensor Module**

![][image1]
  
  **Figure 1:** 

  

**Description:** 

There are two columns visible in this sensor, and one of them has an **IR diode**. A **phototransistor** is located in the other column. Upon activating the sensor, a connection is established between these two columns.   
In other words, the phototransistor absorbs the infrared radiation that the infrared diode emits. 

**Case 1:** When the sensor is **not blocked,** the LED will light **on** and the digital output will be in the **LOW** state. 

**Case 2 :** When the sensor is **covered ,** the LED light is **off** and the digital output will be in the **HIGH** state.

The sensor then sends a signal to us. In other words, we can obtain it in an analog or digital format. Additionally, the **LM393** comparator IC in this sensor module can provide digital readings.

The module includes two LEDs, one LED as power indicator and another LED is for digital output indicator.

**Specifications**

* Operating Voltage: 3.3V to 5V DC  
* Signal Output: Digital  
* Detection Method: Infrared (IR) reflection  
* Output Type: Pulse signal  
* Output Signal Frequency: Depending on the number of encoder pulses  
* Detection Distance: Typically 1-10 mm (depends on the reflective surface and module design)  
* Output Form: Digital level output (0,1)  
* Response Time: Fast, suitable for high-speed rotation detection  
* Operating Temperature Range: \-10¬∞C to 70¬∞C  
* Dimensions: Varies by manufacturer, typically around 32mm x 14mm x 12mm

**Pin Configuration**

* VCC: Power supply (3.3V-5V)  
* GND: Ground  
* DO: Digital output signal (pulses output )  
* AO: Analog Output Signal (pulse)


![][image2] 

 **Figure 2 :** 
                              
  

This Encoder Sensor Module is designed to measure the speed and direction of rotation of a wheel or shaft. It is commonly used in robotics, motor control systems, and other applications where accurate speed detection is required.

![][image3]  
  **Figure 3: Ray Interrupt**

 Here‚Äôs a description of the Speed Encoder Sensor Module:

**Optical Encoder**: It works based on the principle of interrupted light beams as the rotating wheel or shaft passes through the sensor.

**Pulse Output:** The pulses are typically in the form of square waves. .  
   
**Sensitivity:** Variations in the interrupting pattern.

**Digital Interface:** The speed encoder sensor module interfaces with the Arduino or other microcontrollers through digital input pins. The Arduino can read the pulse signals and calculate the speed and direction of rotation using appropriate programming techniques.

**Speed and Direction Detection:** The sensor module can detect the rotational speed of the wheel or shaft and determine the direction of rotation . It does this by counting the number of interruptions or pulses generated by the encoder as the wheel rotates.  
 

**Compatibility:** The module is designed to work seamlessly with Arduino boards, making it convenient for integration into Arduino-based projects.

**Applications:** The Speed Encoder Sensor Module finds applications in various projects that require speed and motion control, such as motor speed regulation, robotics navigation, odometers for vehicles, and more.

**Resolution and Accuracy:** The resolution and accuracy of the module depend on factors like the number of interruptions per revolution (pulses per revolution). Higher pulse counts per revolution generally result in better resolution and accuracy.

**Power Supply:** The module typically operates within a voltage range of 3.3V to 5V, which is compatible with the Arduino‚Äôs voltage levels.  
   For 5V it may cause losses and increase the chance of false triggering due to rapid motion under which the encoder needs to use debounce logic to minimize. So using 3.3V may be a suitable idea but it  may make it difficult to meet the square waves upper limit for digital output .

Overall, the Speed Encoder Sensor Module for Arduino provides a simple and effective way to measure the speed and direction of rotation in various applications.

**CODE:** 

1) \#define SENSOR\_PIN \*(pin number)

2) attachInterrupt(digitalPinToInterrupt(SENSOR\_PIN), readSensor, CHANGE);  
     
     **Interrupt Modes**:  
* Sensor 1: LOW (triggers repeatedly while the pin is LOW).  
* Sensor 2: RISING (triggers on LOW-to-HIGH transition).  
* Sensor 3: FALLING (triggers on HIGH-to-LOW transition).  
* Sensor 4: CHANGE (triggers on any state change, LOW-to-HIGH or HIGH-to-LOW).




3) **Main logic for encoder**   
      void readSensor() {  
     static int lastState \= HIGH;  
    int currentState \= digitalRead(SENSOR\_PIN);  
          if (currentState \!= lastState){  
   position \++;  // or position \--;   
   }

lastState \= currentState;  
        }

4) **Code for all interrupt**   
- ***Logic: Each sensor increments its own position counter when its ISR is triggered, with debouncing to handle mechanical noise.***


  

   **1):  LOW triggering** 


- **LOW Mode Behavior:** The LOW mode ***triggers continuously*** while the pin is **LOW**, which can be **problematic for counting**. The code mitigates this by only incrementing on a LOW transition, but you may need to adjust based on your sensor‚Äôs behavior (e.g., disable the interrupt after one trigger and re-enable it later)**.**  
- attachInterrupt(digitalPinToInterrupt(SENSOR\_PIN), readSensor, LOW);

   void readSensor1() {  
    static int lastState \= HIGH; // Assume opposite of trigger condition  
    static unsigned long lastInterruptTime \= 0;  
    unsigned long currentTime \= millis();  
    if (currentTime \- lastInterruptTime \> DEBOUNCE\_DELAY) {  
        int currentState \= digitalRead(SENSOR\_PIN\_1);  
        if (currentState \== LOW && lastState \!= LOW) { // Only count on transition to LOW  
            position1++;  
            lastState \= currentState;  
        } else if (currentState \== HIGH) {  
            lastState \= currentState; // Reset state when no longer LOW  
        }  
    }  
    lastInterruptTime \= currentTime;  
}

**2\)  RISING triggering  (RISING mode)**

- attachInterrupt(digitalPinToInterrupt(SENSOR\_PIN), readSensor, RISING);

 void readSensor2() {  
    static int lastState \= LOW;  
    static unsigned long lastInterruptTime \= 0;  
    unsigned long currentTime \= millis();  
    if (currentTime \- lastInterruptTime \> DEBOUNCE\_DELAY) {  
        int currentState \= digitalRead(SENSOR\_PIN\_2);  
        if (currentState \!= lastState) { // Confirm state change  
            position2++;  
            lastState \= currentState;  
        }  
    }  
    lastInterruptTime \= currentTime;

}

**3\) FALLING triggering (FALLING mode)**

- attachInterrupt(digitalPinToInterrupt(SENSOR\_PIN), readSensor, FALLING);

void readSensor3() {  
    static int lastState \= HIGH;  
    static unsigned long lastInterruptTime \= 0;  
    unsigned long currentTime \= millis();  
    if (currentTime \- lastInterruptTime \> DEBOUNCE\_DELAY) {  
        int currentState \= digitalRead(SENSOR\_PIN\_3);  
        if (currentState \!= lastState) { // Confirm state change  
            position3++;  
            lastState \= currentState;  
        }  
    }  
    lastInterruptTime \= currentTime;

}

**4  Both triggering (CHANGE mode)**

- attachInterrupt(digitalPinToInterrupt(SENSOR\_PIN), readSensor, CHANGE);

void readSensor4() {  
    static int lastState \= LOW;  
    static unsigned long lastInterruptTime \= 0;  
    unsigned long currentTime \= millis();  
    if (currentTime \- lastInterruptTime \> DEBOUNCE\_DELAY) {  
        int currentState \= digitalRead(SENSOR\_PIN\_4);  
        if (currentState \!= lastState) { // Count on any state change  
            position4++;  
            lastState \= currentState;  
        }  
    }  
    lastInterruptTime \= currentTime;

}

        

5)  **With motor and encoder using interrupt to detect  direction & position (using debounce and interrupt calls when change)**

void readSensor() {  
  static int lastState \= HIGH;  
  static unsigned long lastInterruptTime \= 0;

  const unsigned long debounceDelay \= 40; // ms 

 int currentState \= digitalRead(SENSOR\_PIN);

  unsigned long currentTime \= millis();

 if ((currentState \!= lastState) && (currentTime \- lastInterruptTime \>= debounceDelay)) {  
    if (digitalRead(IN1) \== LOW && digitalRead(IN2) \== HIGH) {  
        pos--;  
        Serial.print("Decrease: ");  
        Serial.println(pos);  
        
    } else if (digitalRead(IN1) \== HIGH && digitalRead(IN2) \== LOW) {  
          pos++;  
        Serial.print("Increase: ");  
        Serial.println(pos);  
        
    }  
    lastInterruptTime \= currentTime;  
  }  
  lastState \= currentState;

}

**Things to Remember üëç**

1. #### **Non-Volatile Variable for position**

   1. The position variable is *modified in the ISR*. If position is a global variable, it must be declared as volatile to ensure proper handling in an interrupt context. This is because the ISR can modify position at any time, and the compiler needs to know not to optimize access to it.  
   2. Without **volatile**, the main program might not see the updated value of position.

2. #### **Debouncing for Mechanical Sensors**

   1. If **SENSOR\_PIN** is connected to a mechanical sensor (e.g., encoder), the signal may ‚Äúbounce,‚Äù causing multiple rapid state changes for a single event. The ISR will trigger for each bounce, leading to incorrect position increments.  
   2. The code needs debouncing logic, which is critical for mechanical sensors.  
3. **ISR Best Practices (Interrupt Service Routine)**  
   1. ISRs should be as short and fast as possible to avoid blocking other interrupts or the main program.  
   2. However, on most Arduino boards (e.g., Uno, Mega ), millis() is safe. And try to avoid using delay() inside ISR .  
        
4. **Pin Selection:** Ensure the sensor pins are interrupt-capable on your board. For Arduino Uno, only pins 2 and 3 support interrupts, so you‚Äôd need a board like Mega. .  
     
5.   
  







  [image1]:/DC_Motor_with_Optical_Encoder/Info(Other%20Details)/images/image1.png

  [image2]:/DC_Motor_with_Optical_Encoder/Info(Other%20Details)/images/image2.png
  [image3]:/DC_Motor_with_Optical_Encoder/Info(Other%20Details)/images/image3.png
